{"/":{"title":"Introduction","data":{"":"","the-mamoru-network#The Mamoru Network":"Mamoru, which means \"protect\" in Japanese, is a decentralized network dedicated to monitoring and responding to smart contract exploits in near real-time. Its primary objective is to ensure the security and integrity of blockchain systems and their associated smart contracts.As a real-time detection solution, Mamoru focuses on both security and operational monitoring of blockchain activity. By utilizing advanced artificial intelligence and machine learning algorithms, the network is able to identify potential vulnerabilities and exploits in smart contracts, as well as monitor and respond to any suspicious transactions or malicious activities.The decentralized nature of Mamoru allows for a highly resilient and distributed system, free from single points of failure, making it a reliable solution for protecting decentralized applications (dApps), cryptocurrencies, and other blockchain-based platforms. This unique approach to security ensures that Mamoru can adapt and integrate seamlessly with a variety of blockchain ecosystems, providing end-users with an effective and robust defense against smart contract exploits and other potential threats.This guide aims to assist you in your development journey for Mamoru by explaining the core concepts of real-time blockchain cybersecurity threat detection. By understanding these key concepts, you will be better equipped to develop and implement effective security measures within the Mamoru network.\nDecentralized Network: Mamoru's decentralized network is designed to eliminate single points of failure, ensuring resilience and reliability. This distributed architecture enables the system to function efficiently and securely, protecting blockchain systems from threats even if a portion of the network is compromised.\nReal-time Monitoring: Mamoru constantly monitors blockchain activity, detecting and analyzing transactions, smart contract executions, and other relevant events as they occur. This real-time monitoring allows Mamoru to rapidly identify and respond to threats and vulnerabilities, minimizing potential damage.\nArtificial Intelligence and Machine Learning: Mamoru leverages advanced AI and ML algorithms to analyze blockchain data, detect patterns, and identify potential threats or anomalies. These technologies allow the system to adapt and improve its detection capabilities over time, ensuring it remains effective against evolving threats.\nSmart Contract Exploits: A primary focus of Mamoru is identifying and responding to smart contract exploits. Smart contracts are self-executing agreements with the terms directly written into code. They can be vulnerable to exploits due to coding errors, design flaws, or other issues. Mamoru's ability to detect and respond to these exploits in near real-time is essential to protect the integrity of the underlying blockchain systems.\nIntegration and Adaptability: Mamoru is designed to seamlessly integrate with various blockchain ecosystems, providing flexible and adaptable security solutions. This adaptability ensures that Mamoru can effectively protect a wide range of blockchain platforms and technologies.\nProactive Threat Detection: Mamoru emphasizes proactive threat detection, working to identify and address vulnerabilities before they can be exploited. By actively scanning and analyzing blockchain data, Mamoru can detect potential weaknesses and implement appropriate countermeasures to prevent exploitation.\n\nBy understanding these core concepts of real-time blockchain cybersecurity threat detection, developers can better leverage the capabilities of the Mamoru network and build more secure and reliable blockchain systems. This understanding will enable you to make informed decisions regarding the design and implementation of security measures within your own blockchain projects, ultimately helping to protect the assets and operations of your users."}},"/Daemons/wasm-daemon":{"title":"WASM Daemon Development","data":{"":"WASM Daemons allow you to define incident matching logic using any language that can be compiled to WebAssembly.\nCurrently, only AssemblyScript is supported.\nYou can write a custom code against a blockchain context, decide when to emit an incident, customize message, severity, etc.\nPrerequisite\nSetup environment\nDefine contract for monitoring\n\n\nCreating a Daemon\nTesting\nDeploying","prerequisite#Prerequisite":"","setup-environment#Setup environment":"","install-validatoin-chaind#Install validatoin-chaind":"You need the validation-chaind CLI to interact with the Mamoru Validation Chain.\nIt is available in the mamorufoundation/validation-chain:latest docker image.Usage:\ndocker run -it --rm mamorufoundation/validation-chain:latest {subcommand}\nConsider creating a command alias for convenience:\nalias validation-chaind=\"docker run -it --rm -v $HOME/.validation-chain:/root/.validation-chain mamorufoundation/validation-chain:latest\"","create-and-fund-an-account#Create and fund an account":"Execute the following command:\nvalidation-chaind keys add wasm-daemon-guide\nThis commands adds an account named wasm-daemon-guide to your keychain.\nTake the newly created account address (look like cosmos1qaar0r0tyyy6ufslam0hv9zvhvy0z0cv5x8xev) and fund it with some tokens.// TODO: make public faucet for a testnet","define-contract-for-monitoring#Define contract for monitoring":"In this guide, we will work with Gnosis Safe contract in Ethereum Goerli network.\nThe contract source code can be found here.","creating-a-daemon#Creating a Daemon":"","init-assemblyscript-project#Init AssemblyScript project":"First, we need to init the project template.\nCreate a new directory, cd into it and run the following commands:\nnpm init\nnpm install --save-dev assemblyscript@0.26.3\nnpx asinit .","write-the-daemon-code#Write the daemon code":"Let's emit an incident if someone withdraws money from the Safe.\nThe function we need is called execTransaction, the code is located here.As we can see from the code, the function emits ExecutionSuccess(bytes32,uint256) event on success.\nKeccak-256 hash of the event is 0x442e715f626346e8c54381002da614f62bee8d27386535b2521ec8540898556e.\nWe will be tracking this event in the network transactions and emit an incident if it's found.This how AssemblyScript Mamoru Daemon code may look like:\nimport { query, report } from \"@mamoru-ai/mamoru-sdk-as/assembly\";\n\n// `ExecutionSuccess(bytes32,uint256)` event\nconst SAFE_EXECUTION_SUCCESS_HASH: string = \"0x442e715f626346e8c54381002da614f62bee8d27386535b2521ec8540898556e\";\n\n// the address of your Gnosis Safe\nconst MY_SAFE_ADDRESS: string = \"0x785a205084ac256cad3133326abee31b5e53931a\";\n\nexport function main(): void {\nlet rows = query(`SELECT bytes_to_hex(e.topic0) AS topic0 FROM events e WHERE e.address = '${MY_SAFE_ADDRESS}'`);\n\nrows.forEach(row => {\nif (row.getString(\"topic0\")!.valueOf() == SAFE_EXECUTION_SUCCESS_HASH) {\nreport();\n}\n})\n}\nReplace MY_SAFE_ADDRESS to yours and put the resulting code into ./assembly/index.ts.\nThen, compile the code into WebAssembly binary:\nnpx asc ./assembly/index.ts --target release --exportRuntime\nYou'll see a file ./build/release.wasm that is the compiled daemon in WebAssembly format.","heres-another-example-of-a-wasm-daemon#Here's another example of a WASM daemon":"Here's an example of a Mamoru WASM daemon that listens for ExecutionSuccess events in a Gnosis Safe contract and reports the transaction hash for each detected event:\n// File: mamoru_daemon.ts\n\nimport { query, report } from \"@mamoru-ai/mamoru-sdk-as/assembly\";\n\nconst SAFE_EXECUTION_SUCCESS_HASH: string = \"0x442e715f626346e8c54381002da614f62bee8d27386535b2521ec8540898556e\";\nconst MY_SAFE_ADDRESS: string = \"0x785a205084ac256cad3133326abee31b5e53931a\";\nconst POLL_INTERVAL: u32 = 60000; // 60 seconds\n\nexport function main(): void {\nlet lastProcessedBlock: u64 = 0;\n\nwhile (true) {\nlastProcessedBlock = checkExecutionSuccessEvents(lastProcessedBlock);\nsleep(POLL_INTERVAL);\n}\n}\n\nfunction checkExecutionSuccessEvents(lastBlock: u64): u64 {\nconst latestBlockNumber = getLatestBlockNumber();\nconst rows = queryEventsByAddressAndBlockRange(MY_SAFE_ADDRESS, lastBlock + 1, latestBlockNumber);\n\nrows.forEach(row => {\nif (isExecutionSuccessEvent(row)) {\nconst txHash = row.getString(\"transaction_hash\")!;\nreport(txHash);\n}\n});\n\nreturn latestBlockNumber;\n}\n\nfunction getLatestBlockNumber(): u64 {\nconst sqlQuery = \"SELECT max(b.block_number) as latest_block FROM blocks b\";\nconst result = query(sqlQuery);\nconst latestBlockNumber = result.getRow(0).getU64(\"latest_block\");\nreturn latestBlockNumber;\n}\n\nfunction queryEventsByAddressAndBlockRange(address: string, startBlock: u64, endBlock: u64): ArrayBuffer {\nconst sqlQuery = `\nSELECT bytes_to_hex(e.topic0) AS topic0, e.transaction_hash\nFROM events e\nWHERE e.address = '${address}' AND e.block_number BETWEEN ${startBlock} AND ${endBlock}`;\n\nreturn query(sqlQuery);\n}\n\nfunction isExecutionSuccessEvent(row: ArrayBuffer): boolean {\nconst eventHash = row.getString(\"topic0\")!.valueOf();\nreturn eventHash == SAFE_EXECUTION_SUCCESS_HASH;\n}\n\nfunction sleep(ms: u32): void {\n// Mamoru does not currently support blocking sleep operations in AssemblyScript.\n// You might need to implement this function using JavaScript and Web Workers or other non-blocking techniques.\n}","testing#Testing":"Testing are not implemented for daemons yet.\nHowever, WASM daemons are validated during deploying phase.\nYou will receive an error message if your WASM module is invalid, some types are incompatible etc.","deploying#Deploying":"To deploy the daemon to Mamoru Validation Chain Testnet, you must submit a register-daemon transaction:\nexport DAEMON_BINARY=$(cat ./build/release.wasm | base64)\n\n# TODO: the command is not valid yet, as per changes in `validation-chaind`\nvalidation-chaind tx \\\nvalidationchain register-daemon \"{\\\"content\\\": \\\"${DAEMON_BINARY}\\\", \\\"chain\\\": {\\\"chain_type\\\": 4}}\" \\\n--from wasm-daemon-guide \\\n--node https://validation-chain.testnet.mamoru.foundation:26657 \\\n--chain-id validationchaintestnet\nAfter a few minutes, Mamoru Sniffers will fetch your daemon and start running your daemon against blockchain transactions."}},"/Appendix/glossary":{"title":"Glossary of Mamoru Terms","data":{"":"","cli#CLI":"The CLI is a globally installed npm package that provides access to the mamoru-cli command in your terminal. It allows you to scaffold both SQL and WASM Daemons via mamoru-cli init.","validation-chain#Validation Chain":"The validation chain is the core of Mamoru. It validates incoming incident reports, manages Daemons and DaemonMetadatas, and registers them in the blockchain.","daemon#Daemon":"A daemon is an entity deployed on a specified blockchain that detects and emits incidents to the validation chain.","sql-daemon#SQl Daemon":"SQL Daemons allow you to define incident matching logic using SQL. You can write an SQL query against a blockchain context, and if it returns something, the system emits an incident.","wasm-daemon#Wasm Daemon":"WASM Daemons allow you to define incident matching logic using any language that can be compiled to WebAssembly. Currently, only AssemblyScript is supported. You can write a custom code against a blockchain context, decide when to emit an incident, customize message, severity, etc.","daemon-metadata#Daemon Metadata":"Each daemon uses a \"master template\" that can be defined as a series of SQL queries or WASM code. This template is called \"Daemon Metadata\" and can be shared among many daemons if the developer allows it. Sharing a single metadata as the common source for several daemons allows each daemon to have a set of custom parameters defined during the creation of the metadata.","the-centralized-platform#The Centralized Platform":"The centralized platform is responsible for listening to all events from the validation chain and sending notifications (SMS, email, webhook, Discord, etc.) to several subscribers. Users can manually or programmatically subscribe to daemon events and provide custom templates to format the data.© Copyright 2023 Mamoru.ai - MIT License"}},"/CLI/instructions":{"title":"Publishing the daemon.","data":{"":"","installation#Installation":"Mamoru-CLI requires Node.js 16.x.x, you can manage multiple version of Node on the same machine using nvm (MacOs, Linux) or nvm for windowsTo install the new package, use one of the following commands. You will need administrator privileges to execute these commands, unless npm was installed on your system through a Node.js version manager (such as n or nvm).","using-npm#Using NPM":"npm install -g mamoru-cli","using-yarn#Using Yarn":"yarn global add mamoru-cli","upgrading#Upgrading":"To upgrade the global Mamoru-CLI package, run:","using-npm-1#Using NPM":"npm update -g mamoru-cli","using-yarn-1#Using Yarn":"yarn global upgrade --latest mamoru-cli\nTo create a new project, run:\nmamoru-cli init my-new-daemon --type sql --chain sui\nThis command will create a SQL project targeting sui blockchain in the \"my-new-daemon\" folder. To see all available parameters for the command, please check the referenceOnce the project is created, you will see a prompt similar to this:\n\nTo get started, move to your directory and install dependencies using either npm install or yarn.You should see four files for SQL daemons:\nReadme.md: This is a placeholder readme file for your project.\nmanifest.yml: This file defines basic information about the daemon, such as its type, name, a custom logo URL, the target chain, and custom tags for discoverability.\npackage.json: This is a minimal standard package.json file from NPM. It allows you to install custom AssemblyScript packages from the npm registry, and it's especially useful for WASM daemons. It also contains the build scripts used for WASM daemons.\nqueries.yml: This file defines the queries that the daemon will run. At the time of deployment, these queries will be sent in the form of daemon metadata.\n\nThe building step is only required for WASM daemons. During this step, your AssemblyScript source code will be transformed into a .wasm file that will later be sent to the validation chain as a daemon metadata. The dependencies required for compiling the source code are specified in the package.json file of each project, so each project can evolve at a different pace.To run the build step use\nmamoru-cli build\nUpon successful execution of the command, a build directory will appear in your project root.Once your project is completed, you can deploy your first daemon using the following command:\nmamoru-cli deploy --private-key <YOUR_PRIVATE_KEY>\nThe deploy command works in slightly different ways depending on the characteristics of your Daemon. Here, we provide a basic overview of these differences.","for-sql-daemons#For SQL Daemons":"In this case, the deploy command verifies the manifest.yml and queries.yml files, transforms and signs the transaction using your private key, and sends it to the validation chain as a Daemon Metadata.","for-wasm-daemons#For WASM Daemons":"The deploy command verifies the existence of the build folder and performs a small validation of the sources. It then converts the binary to base64 format, creates and signs the transaction using the private key, and finally uses it to create a Daemon Metadata.Keep in mind that the base64 string of the binary may require extra gas to be processed. Depending on your case, you may need to add some extra gas. To do this, use the --gas flag.\nmamoru-cli deploy --private-key <YOUR_PRIVATE_KEY> --gas 1000000","for-sole-or-subscribable-daemons#For SOLE or SUBSCRIBABLE Daemons":"At this point, you may have noticed a subscribable field in your manifest.yml file. Daemons can have two types: SOLE or SUBSCRIBABLE.Creating a SOLE daemon means that only you can spawn new instances of the daemon metadata. In this case, running the deploy command will first create the Daemon Metadata, and then the Daemon itself in a subsequent call.Creating a SUBSCRIBABLE daemon means that the deploy command will only create a Daemon Metadata, and the Daemon instance can be spawned later by you or any other person interacting with the validation chain."}},"/CLI/introduction":{"title":"The Mamoru CLI","data":{"":"","overview#Overview":"Mamoru CLI is a system designed to rapidly develop Mamoru Daemon applications. It provides:\nProject scaffolding\nA build system\nA publishing system for validation chains\n\nMamoru CLI aims to be the standard tool for creating daemons within the Mamoru project. We work continuously to ensure that each piece works smoothly and is easy to use.","components#Components":"","cli#CLI":"The CLI is a globally installed npm package that provides access to the mamoru-cli command in your terminal. It allows you to scaffold both SQL and WASM Daemons via mamoru-cli init.","validationchain#ValidationChain":"The validation chain is the core of Mamoru. It validates incoming incident reports, manages Daemons and DaemonMetadatas, and registers them in the blockchain.","daemon#Daemon":"A daemon is an entity deployed on a specified blockchain that detects and emits incidents to the validation chain.","daemon-metadata#Daemon Metadata":"Each daemon uses a \"master template\" that can be defined as a series of SQL queries or WASM code. This template is called \"Daemon Metadata\" and can be shared among many daemons if the developer allows it. Sharing a single metadata as the common source for several daemons allows each daemon to have a set of custom parameters defined during the creation of the metadata.","the-centralized-platform#The centralized platform":"The centralized platform is responsible for listening to all events from the validation chain and sending notifications (SMS, email, webhook, Discord, etc.) to several subscribers. Users can manually or programmatically subscribe to daemon events and provide custom templates to format the data."}},"/Appendix/references":{"title":"Mamoru CLI Reference","data":{"":"","basic-usage#Basic Usage":"mamoru-cli [options] [command]\n\nOptions:\n-v, --verbose             define verbosity to show execution logs\n-h, --help                display help for command","commands#Commands":"","init#init":"Usage:  init [options] <path>\n\nArguments:\npath                             path to folder with queryable project (default: \"\")\n\nOptions:\n-t, --type <type>                Type of project (choices: \"sql\", \"wasm\", default: \"wasm\")\n-c, --chain <chain>              Chain where the daemon runs (choices: \"ethereum\", \"bsc\", \"sui\")\n-n, --name <name>                Name of the project (default: \"Default Name\")\n-d, --description <description>  Description of the project (default: \"Mamoru Daemon\")\n-t, --tags <tags>                Tags of the project, comma separated (default: \"mamoru,daemon\")\n-l, --logo <logo>                Logo of the project, should be an url (default:\n\"https://mamoru.ai/default-daemon-logo.png\")\n--subscribable                   If the project is subscribable, or standalone (default: false)\n-h, --help                       display help for command","build#build":"Usage:  build [options] [path]\n\ncompile project\n\nArguments:\npath        path to folder with queryable project (default: \".\")\n\nOptions:\n-h, --help  display help for command","publish#publish":"Usage:  publish [options] [path]\n\npublish project\n\nArguments:\npath                     path to folder with queryable project (default: \".\")\n\nOptions:\n--rpc <rpcUrl>           rpc url of the chain\n--gas <gas>              gas fee of the transaction (default: \"200000\")\n-k, --private-key <key>  Private key of the account that will be used to publish the project\n-h, --help               display help for command"}}}